# Go para API Rest e gRPC server

## Índice

- [Tecnologias](#tecnologias)
- [Arquitetura](#arquitetura)
- [Estrutura de pastas e diretórios](#estrutura-de-pastas-e-diretórios)
- [Como funciona?](#como-funciona)
- [Convenções](#convenções)
- [Novo projeto](#novo-projeto)
- [Como contribuir?](#como-contribuir)


## Arquitetura

![Diagram](assets/architecture.png)

Arquitetura de software é uma estrutura que suporta os casos de uso do projeto
com o objetivo de facilitar a manutenção do código.
A arquitetura criada aqui foi inspirada em Clean Architecture e Domain-Driven
Design (DDD). As seguintes premissas foram adotadas:

- Independência de Frameworks
- Fácil de testar
- Estrutura de dados flexível
- Injeção de dependência
- Encapsulamento de bibliotecas externas
- Agilidade na mudança de banco de dados

As decisões para alcançar as premissas foram:

- Entities representam estrutura de dados do domínio da aplicação e regras de negócio
- Models são estruturas de dados simples que trafegam entre as camadas até serem convertidos de/para entities
- Gateways armazenam e recuperam informações de sistemas externos (banco de dados, APIs remotas, filesystem...)
- Services contém as regras de negócio e atuam orquestrando entities e gateways
- Infra é a camada para código que não pertencem a lógica de negócio
- Controllers orquestram o fluxo da aplicação desde a entrada de dados até a saída deles
- Suporte a múltiplos databases
- Suporte a API Rest, gRPC, gRPC-Web e Websockets
- Todas as interfaces ficam isoladas das implementações


## Estrutura de pastas e diretórios

```
.
├── cmd/                               # The entrypoint where main.go lives
│   ├── webapp/
│   │   └── main.go
├── src/
│   ├── infra/
│   │   ├── frameworks/ 
│   │   │   ├── container.go           # Inject dependencies and start all servers
│   │   │   ├── httpserver/            # HTTP Server for RESTFul APIs
│   │   │   │   ├── router/            # Routes definitions
│   │   │   │   └── controllers/       # Handle requests and responses
│   │   │   ├── websocketserver        # Websocket
│   │   │   ├── grpcwebserver/         # gRPC Web server over the HTTP server
│   │   │   │   └── controllers/       # Handle requests and responses
│   │   │   └── grpcserver/            # gRPC Server
│   │   │       └── controllers/       # Handle requests and responses
│   │   ├── datastores/                # Databases and external storage
│   │   ├── conf/                      # Global configuration
│   │   ├── test/                      # Help to testing the all layers
│   │   ├── logger/                    # Log data
│   │   └── metrics/                   # Hardware resources metrics
│   ├── domain/
│   │   ├── entities/                  # A data structure that represents business and its rules
│   │   ├── services/                  # Business roles
│   │   └── gateways/                  # Access to databases and external storages
│   ├── shared/                        # Utilities that could be used by any layers
│   ├── interfaces/                    # Go interfaces
│   ├── proto/                         # Stubs generated by protoc compiler
│   └── init/                          # System init and process manager/supervisor configs
├── assets/                            
│   ├── static/                        # Static files will be embed and served via /static endpoint
│   │   └── proto/                     # Protocol buffer definitions source files
│   └── web/                           # HTML files will be embed and renderized by HTTP server
├── sdk/                               # SDK for clients
├── scripts/                           # Shell scripts for dev/devops needs
├── migrations/                        # History of database changes and initial data
├── .editorconfig                      # Editor config
├── .gitignore                         # GIT ignore paths
├── config.linux.yaml                  # Config file for local development on Linux
├── config.macos.yaml                  # Config file for local development on MacOS
├── config.test.yaml                   # Config file for testing
└── README.md                          # Initial documentation
```

## Como funciona?

### Tecnologias

#### Echo Framework

Echo é uma framework para desenvolvimento web que facilita a criação de APIs
Rest e renderização de templates HTML.  Suas principais características são:

- Router otimizado com zero alocação de memória dinâmica Organização de APIs em grupos
- Suporte a HTTP/2 Fácil de adicionar middlewares Data binding para o payload de request HTTP
- Renderização de templates

#### gRPC (Google Remote Procedure Call)

O gRPC é um protocolo de comunicação criado pelo Google no qual serviços
distribuídos podem se comunicar sem necessidade de entendimento da camada de
rede.  Os dados são transmitidos pela rede em formato binário, diferente do
HTTP que utiliza texto puro.  

Esse protocolo utiliza o modelo client/server. O desenvolvedor especifica em um
arquivo texto, utilizando uma sintaxe chamada Protobuf, quais serviços serão
expostos no server.  O arquivo deve ser disponibilizado para que outros
desenvolvedores possam utilizar o compilador `protoc` para ler essas definições
e criar um **stub** para a linguagem de programação utilizada pelo client.  Por
fim, o client só precisa importar o stub como uma biblioteca de terceiros e
invocar as funções dos serviços expostos pelo server.

#### gRPC Web

O gRPC Web é uma implementação Javascript de gRPC client para browsers.  Ele é
totalmente compatível com gRPC servers rodando em Go. Para outras linguagens é
necessário adicionar o proxy Envoy para traduzir a requisição enviada do
browser antes de encaminha-la para o server.

Basta importar os stubs gerados para Javascript e chamar as respectivas funções
de acordo com o serviço exposto. O gRPC Web converte os dados para binário e
envia usando HTTP POST. O server em Go roda um servidor HTTP que intercepta as
requisições desse tipo e trata como requisições gRPC.

Exemplo de um arquivo com definições de serviços escrito em Protobuf:

```proto
syntax = "proto3";

package private;
option go_package = "proto";

service AccountService {
    rpc Create(User) returns (User) {}
    rpc AuthenticateByEmailAndPassword(User) returns (Account) {}
}

message User {
    string email = 1;
    string password = 2;
}

message Account {
    string token = 1;
}
```

### Arquitetura

Fluxo dos dados:

1. O controller recebe o input de dados. Deve existir controllers diferentes para cada tipo, HTTP, gRPC e gRPC Web
2. O controller utiliza um Adapter dele para converter a estrutura de dados de/para entity
3. O controller envia a Entity para o Service que pode ou não ter alguma regra de negócio
4. O Service altera a Entity, se necessário, e encaminha para o Gateway
5. O Gateway armazena ou recupera os dados a partir de um database ou API externa

## Convenções

As principais convenções adotadas foram:

- Structs Container que possuem os services e gateways injetados
- Nome de arquivos possuem o sufixo de acordo com seu tipo. Ex.: `TodoService.go` para um service
- Arquivos de testes com sufixo `_test` no nome do arquivo e no package, localizados no mesmo diretório das implementações
- Configuração via arquivo YAML por ambiente
- Suporte a múltiplos banco de dados
- Customização de erros para facilitar o retorno dos status code do HTTP e gRPC

## Novo projeto

### Primeiros passos

Instale as dependências com `make setup` e siga as instruções para a instalação manual das ferramentas para gRPC.

```sh
make setup     # Instala as dependências
make sqlite    # Cria um arquivo database.db utilizando migrations/sqlite/schema.sql
make postgres  # Cria um container Docker rodando Postgres utilizando migrations/postgres/schema.sql
make proto     # Roda o compilador protoc para gerar os stubs a partir do assets/static/main.proto
make lint      # Roda o goimports para formatar o código Go
make docs      # Cria doc swagger
make mocks     # Cria mocks para os testes
make test      # Executa os testes unitários
make start     # Roda a aplicação em localhost
```

## Como contribuir?

1. Abra uma issue para discutir sua proposta de mudança e se ela será aceita
2. Faça um fork desse repositório se sua mudança for aceita
3. Crie um feature branch: `git checkout -b my-new-feature`
4. Faça um commit e push das suas mudanças: `git commit -am 'Add some feature' && git push origin my-new-feature`
5. Crie um pull request
